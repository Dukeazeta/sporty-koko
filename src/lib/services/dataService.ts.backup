// src/lib/services/dataService.ts

export interface Match {
    id: number;
    homeTeam: string;
    homeTeamId: number;
    awayTeam: string;
    awayTeamId: number;
    date: string;
    status: string;
    score: {
        home: number | null;
        away: number | null;
    };
}

export interface Competition {
    id: number;
    name: string;
    emblem: string;
    code: string;
}

const API_KEY = process.env.FOOTBALL_DATA_API_KEY;
const BASE_URL = 'https://api.football-data.org/v4';

if (!API_KEY) {
    console.error("FOOTBALL_DATA_API_KEY is not set in environment variables.");
}

const headers = {
    'X-Auth-Token': API_KEY || '',
};

// Rate limit management
export interface RateLimitInfo {
    isRateLimited: boolean;
    resetTime?: string;
    remainingRequests?: number;
    cooldownMinutes?: number;
}

let rateLimitInfo: RateLimitInfo = {
    isRateLimited: false,
    resetTime: undefined,
    remainingRequests: undefined
};

// Simple in-memory rate limit tracking
const requestCache = new Map<string, { timestamp: number; count: number }>();
const RATE_LIMIT_WINDOW = 60 * 1000; // 1 minute in milliseconds
const MAX_REQUESTS_PER_WINDOW = 10; // Conservative limit

const checkRateLimit = (): RateLimitInfo => {
    const now = Date.now();
    const windowStart = now - RATE_LIMIT_WINDOW;

    // Clean old entries
    for (const [key, entry] of requestCache.entries()) {
        if (entry.timestamp < windowStart) {
            requestCache.delete(key);
        }
    }

    const recentRequests = Array.from(requestCache.values())
        .filter(entry => entry.timestamp >= windowStart)
        .reduce((sum, entry) => sum + entry.count, 0);

    if (recentRequests >= MAX_REQUESTS_PER_WINDOW) {
        const oldestRequest = Math.min(...Array.from(requestCache.values()).map(e => e.timestamp));
        const resetTime = new Date(oldestRequest + RATE_LIMIT_WINDOW);
        const cooldownMinutes = Math.ceil((resetTime.getTime() - now) / (60 * 1000));

        rateLimitInfo = {
            isRateLimited: true,
            resetTime: resetTime.toISOString(),
            remainingRequests: 0,
            cooldownMinutes
        };

        return rateLimitInfo;
    }

    rateLimitInfo = {
        isRateLimited: false,
        remainingRequests: MAX_REQUESTS_PER_WINDOW - recentRequests
    };

    return rateLimitInfo;
};

const recordRequest = (): void => {
    const now = Date.now();
    const key = `${now}`;
    const existing = requestCache.get(key);

    if (existing) {
        existing.count++;
    } else {
        requestCache.set(key, { timestamp: now, count: 1 });
    }
};

const handleRateLimitResponse = (response: Response): void => {
    const remaining = response.headers.get('X-Requests-Available-Minute');
    const resetTime = response.headers.get('X-RequestCounter-Reset');

    if (response.status === 429) {
        const resetDate = resetTime ? new Date(parseInt(resetTime) * 1000) : new Date(Date.now() + 60 * 1000);
        const cooldownMinutes = Math.ceil((resetDate.getTime() - Date.now()) / (60 * 1000));

        rateLimitInfo = {
            isRateLimited: true,
            resetTime: resetDate.toISOString(),
            remainingRequests: 0,
            cooldownMinutes
        };
    } else if (remaining) {
        rateLimitInfo.remainingRequests = parseInt(remaining);
        rateLimitInfo.isRateLimited = false;
        rateLimitInfo.resetTime = undefined;
    }
};

export const getRateLimitInfo = (): RateLimitInfo => ({ ...rateLimitInfo });

export const resetRateLimit = (): void => {
    rateLimitInfo = {
        isRateLimited: false,
        resetTime: undefined,
        remainingRequests: undefined
    };
    requestCache.clear();
};

export const fetchCompetitions = async (): Promise<{ competitions: Competition[], rateLimitInfo: RateLimitInfo }> => {
    try {
        const rateStatus = checkRateLimit();
        if (rateStatus.isRateLimited) {
            return { competitions: [], rateLimitInfo: rateStatus };
        }

        // Fetch available competitions (tier one)
        const url = `${BASE_URL}/competitions?plan=TIER_ONE`;

        recordRequest();
        const res = await fetch(url, { headers, next: { revalidate: 86400 } }); // Cache for 24h

        handleRateLimitResponse(res);

        if (res.status === 429) {
            return { competitions: [], rateLimitInfo: getRateLimitInfo() };
        }

        if (!res.ok) {
            return { competitions: [], rateLimitInfo: getRateLimitInfo() };
        }

        const data = await res.json();

        const competitions = data.competitions?.map((c: any) => ({
            id: c.id,
            name: c.name,
            emblem: c.emblem,
            code: c.code
        })) || [];

        return { competitions, rateLimitInfo: getRateLimitInfo() };
    } catch (error) {
        console.error("[fetchCompetitions] Error:", error);
        return { competitions: [], rateLimitInfo: getRateLimitInfo() };
    }
};

export const fetchUpcomingMatches = async (competitionId?: number): Promise<{ matches: Match[], rateLimitInfo: RateLimitInfo }> => {
    try {
        const rateStatus = checkRateLimit();
        if (rateStatus.isRateLimited) {
            return { matches: [], rateLimitInfo: rateStatus };
        }

        // If competitionId is provided, fetch matches for that competition
        // Otherwise fetch matches for the next 7 days across all subscribed competitions
        let url = `${BASE_URL}/matches`;

        if (competitionId) {
            // Fetch scheduled matches for the specific competition
            // We use a broader date range or just 'SCHEDULED' status
            const dateFrom = new Date().toISOString().split('T')[0];
            const dateTo = new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]; // Next 2 weeks
            url = `${BASE_URL}/competitions/${competitionId}/matches?dateFrom=${dateFrom}&dateTo=${dateTo}`;
        }

        recordRequest();
        const res = await fetch(url, { headers, next: { revalidate: 60 } });

        handleRateLimitResponse(res);

        if (res.status === 429) {
            return { matches: [], rateLimitInfo: getRateLimitInfo() };
        }

        if (!res.ok) {
            return { matches: [], rateLimitInfo: getRateLimitInfo() };
        }

        const data = await res.json();

        if (!data.matches) {
            return { matches: [], rateLimitInfo: getRateLimitInfo() };
        }

        const matches = data.matches.map((m: any) => ({
            id: m.id,
            homeTeam: m.homeTeam.name,
            homeTeamId: m.homeTeam.id,
            awayTeam: m.awayTeam.name,
            awayTeamId: m.awayTeam.id,
            date: m.utcDate,
            status: m.status,
            score: {
                home: m.score.fullTime.home,
                away: m.score.fullTime.away,
            }
        }));

        return { matches, rateLimitInfo: getRateLimitInfo() };
    } catch (error) {
        console.error("[fetchUpcomingMatches] Error:", error);
        return { matches: [], rateLimitInfo: getRateLimitInfo() };
    }
};

export const fetchTeamHistory = async (teamId: string | number): Promise<{ matches: Match[], rateLimitInfo: RateLimitInfo }> => {
    try {
        const rateStatus = checkRateLimit();
        if (rateStatus.isRateLimited) {
            return { matches: [], rateLimitInfo: rateStatus };
        }

        const url = `${BASE_URL}/teams/${teamId}/matches?status=FINISHED&limit=10`;

        recordRequest();
        const res = await fetch(url, { headers, next: { revalidate: 3600 } });
        handleRateLimitResponse(res);

        if (res.status === 429) {
            return { matches: [], rateLimitInfo: getRateLimitInfo() };
        }

        if (!res.ok) {
            return { matches: [], rateLimitInfo: getRateLimitInfo() };
        }

        const data = await res.json();

        if (!data.matches) return { matches: [], rateLimitInfo: getRateLimitInfo() };

        const matches = data.matches.map((m: any) => ({
            id: m.id,
            homeTeam: m.homeTeam.name,
            homeTeamId: m.homeTeam.id,
            awayTeam: m.awayTeam.name,
            awayTeamId: m.awayTeam.id,
            date: m.utcDate,
            status: m.status,
            score: {
                home: m.score.fullTime.home,
                away: m.score.fullTime.away,
            }
        }));

        return { matches, rateLimitInfo: getRateLimitInfo() };
    } catch (error) {
        console.error(`Error fetching history for team ${teamId}:`, error);
        return { matches: [], rateLimitInfo: getRateLimitInfo() };
    }
};

export const fetchHeadToHead = async (homeTeamId: number, awayTeamId: number): Promise<{ matches: Match[], rateLimitInfo: RateLimitInfo }> => {
    try {
        const rateStatus = checkRateLimit();
        if (rateStatus.isRateLimited) {
            return { matches: [], rateLimitInfo: rateStatus };
        }

        const url = `${BASE_URL}/teams/${homeTeamId}/matches?opponent=${awayTeamId}&status=FINISHED`;

        recordRequest();
        const res = await fetch(url, { headers, next: { revalidate: 86400 } });
        handleRateLimitResponse(res);

        if (res.status === 429) {
            return { matches: [], rateLimitInfo: getRateLimitInfo() };
        }

        if (!res.ok) {
            return { matches: [], rateLimitInfo: getRateLimitInfo() };
        }

        const data = await res.json();

        if (!data.matches) return { matches: [], rateLimitInfo: getRateLimitInfo() };

        const matches = data.matches.map((m: any) => ({
            id: m.id,
            homeTeam: m.homeTeam.name,
            homeTeamId: m.homeTeam.id,
            awayTeam: m.awayTeam.name,
            awayTeamId: m.awayTeam.id,
            date: m.utcDate,
            status: m.status,
            score: {
                home: m.score.fullTime.home,
                away: m.score.fullTime.away,
            }
        }));

        return { matches, rateLimitInfo: getRateLimitInfo() };
    } catch (error) {
        console.error(`Error fetching H2H for ${homeTeamId} vs ${awayTeamId}:`, error);
        return { matches: [], rateLimitInfo: getRateLimitInfo() };
    }
};
